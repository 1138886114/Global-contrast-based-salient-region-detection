Global contrast based salient region detection
=========

### LC
计算某个像素在整个图像上的全局对比度，即该像素与图像中其他所有像素在颜色上的距离之和作为该像素的显著值。
图像 $I$ 中某个像素 $I_k$ 的显著值计算如下：
$$
SalS(I_k) = \sum_{\forall I_i \in I}||I_k - I_i||
$$
其中$I_i$的取值范围为 $[0, 255]$， 即为灰度值。
给定一张图像，每个像素$I_k$的颜色值已知。假定$I_k = a_m$，则上式可进一步重构：
$$
\begin{aligned}
SalS(I_k) &= ||a_m - a_0||+||a_m - a_1|| +...+||a_m - a_n|| \\
SalS(I_k)&= \sum_{n=0} ^{255}f_n||a_m - a_n||
\end{aligned}
$$
其中，$f_n$表示图像中第$n$个像素的频数，以直方图的形式表示。
[**【参考原代码请点击】**](https://asdfv1929.github.io/2018/05/11/saliency-LC/) ，我使用了numpy重写了原函数，优化了代码运行时间。

### HC

HC的显著性图生成主要是基于输入图像的颜色值直方图分布，生成像素级别的显著性值，每个像素点的显著性值是它跟剩下全部图像像素点的对比度（色差）来定义的：
$$
S(I_k) = \sum_{\forall I_k \in I}D(I_k,I_i) \tag{1}
$$

其中D(I_k,I_i)是空间 **L\*a\*b** 中两个像素的颜色距离度量，上式经过扩展像素等级变如下方程：
$$
S(I_k) =D(I_k,I_1) +D(I_k,I_2)+...+D(I_k,I_N) \tag{2}
$$
其中N 为图像 I中的像素数量。
从上式中看出拥有相同像素的值，得到显著性值会相同，把相同的像素值都归为同一类别C_j，对每种颜色得到显著性值：
$$
S(I_k) = S(c_l) = \sum_{j=1}^n f_iD(c_l,c_j) \tag{3}
$$
其中 c_l是像素I_k的颜色值，n 是不同像素颜色的数量，f_i是图像I中像素值C_j出现的频率。这样把上面的像素计算转换为基于直方图的颜色值查找计算。

1. 基于直方图的加速
    把对每个像素点的全图查找 $O(N^2)$ 变换为 $O(N)+O(n^2)$，正常情况直方图的BIN(N)为256，通过对颜色进行量化，每个颜色通道量化为12个不同值。考虑到自然图像中的颜色仅仅包含了全颜色空间中很小的一部分，通过忽略出现频率较低的颜色来进一步减少颜色数量。**通过选择高频颜色并且保证这些颜色覆盖图像像素不低于95%的颜色**，最终达到了n=85个颜色。剩下的像素颜色，包含不高于5%的图像像素，这部分颜色被直方图中最邻近的颜色替代。

  对 **Lab** 色彩空间只在L上计算，但是这种做法有很大的弊端，就是颜色的区分度下降，色彩空间多维度信息没有有效利用，所以一般会对Lab色彩空间的三个维度同时量化生成 颜色值，然后再根据频次优化出现的颜色值范围。确保这些颜色值可以覆盖95%以上的像素点。

2. 颜色空间平滑
    以通过建立直方图使用色彩空间量化的方法加速全局对比度的计算，但是**量化色彩空间**本身就是人为的，有可能把相似的颜色量化成不同的值，为了减少这种现象导致显著性噪声出现，所以对得到显著性值最后完成一个模糊操作，采取一套平滑程序来改善每个颜色的显著值。用相似颜色的显著值加权平均来代替每个颜色（以 **L\*a\*b*** 距离测量）的显著值。选择m=n/4。个最近的颜色作为代表来改善颜色c的显著值：
$$
S'(c) = \frac{1}{(m ~~1)T} \sum_{i=1}^n(T~~D(c,c_i))S(c_i) \tag{4}
$$
  其中，$$T =  \sum_{i=1}^mD(c,c_i)$$是颜色c和它的m个最近的颜色$C_i$之间的距离之和，归一化因数来自公式：
$$
  \sum_{i=1}^m(T~~D(c,c_i)) = (m-1)T
$$

在最后的实现中，在RGB颜色空间中进行颜色量化，每个色彩空间均匀量化为12等分，共$12^3$色彩种类。再在Lab颜色空间中进行距离度量。

- 算法实现流程：
1、量化颜色通道。找出图像中一共有多少种颜色以及对应的像素总数。
2、按照像素总数从大到小排序，并同时记录相应颜色。
3、找出像素数目覆盖图像不小于95%的高频颜色，以及其他的不高于5%的颜色种类，假设高频颜色共有maxnum种。
4、把低频颜色的像素归类到与它lab颜色距离相距最近的高频颜色中。
5、在maxnum种颜色中，计算颜色i到所有其他颜色j的颜色距离。并按照距离从小到大排序，记录相应j的颜色种类。
6、按照方程(3)计算每一种颜色的显著值。根据第5步，可以找到距离颜色i相距最近的m种颜色，从而可以根据方程(4)计算每种颜色显著值，即最终的显著值。
7、为图像中每一个像素分配显著值。像素(i,j)是什么颜色，就赋予它相应颜色的显著值。
8、至此，显著图生成。进行归一化、线性空间滤波。

关于更多详情请点击：https://blog.csdn.net/wsp_1138886114/article/details/102560328